library(igraphdata)
pref <- getPreferencieNetwork(TRUE,3)
pref <- getPreferencieNetwork(FALSE,3)
plot(pred, vertex.label = 1:15)
plot(pref, vertex.label = 1:15)
plot(pref, vertex.label = 1:15, vertex.col = 0)
set.seed(3)
plot(pref, vertex.label = 1:15, vertex.color = 0)
plot(pref, vertex.label = 15:1, vertex.color = 0)
set.seed(3)
plot(pref, vertex.label = 15:1, vertex.color = 0)
ruinf()
ruinf(15)
runif(15)
runif(15)*15
floor(runif(15)*15)
floor(runif(15)*16)
floor(runif(15)*16)
floor(runif(15)*16)
floor(runif(15)*16)
plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0)
plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0, layout = layout_nicely(pref))
plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0,
layout=layout_nicely(g),
vertex.size=18,
vertex.label.family="Times")
set.seed(3)
plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0,
layout=layout_nicely(pref),
vertex.size=18,
vertex.label.family="Times")
plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0)
V(g)
k
a
c(1,2,3,4)
g <- c(1,2,3,4)
setwd("~/Desktop/apps/lap")
# TESTY
source('lpa.R')
preferencie <- getPreferencieNetwork(FALSE,3)
plot(cluster_label_prop(preferencie),preferencie)
lpa(preferencie,TRUE,byFixedLabels = FALSE)
lpa(preferencie,TRUE,byFixedLabels = TRUE)
lpa(preferencie,TRUE,byFixedLabels = TRUE)
lpa(preferencie,TRUE,byFixedLabels = FALSE)
g <- preferencie
#2
networkLength <- length(V(g))
V(g)$label <- 1:networkLength
V(g)$name <- 1:networkLength
g
g$name
V(g)$name
V(g)$label
g
neighbors(g,1)
neighbors(g,"1")
neighbors(g,"1")$name
?neighbors
V(g)$name <- lengtg(V(g)) : 1
V(g)$name <- length(V(g)) : 1
neighbors(g,"1")$name
neighbors(g,1)$name
g
V(g,1)
neighborhood(g,1)
neighborhood(g)
neighborhood(g)[1]
neighborhood(g)[2]
neighborhood(g)[3]
neighbors(g,1)$name
neighbors(g,"1")$name
g
id <- V(g)$name[1]
id
#e
idx <- which(id == V(g)$name)
idx
neighborIds
# ...
# ...
#f
neighborsIds <- neighbors(g,idx)
neighborsIds
# ...
# ...
#f
neighborsIds <- neighbors(g,idx)$name
neighborsIds
# ...
# ...
#f
neighborsIds <- neighbors(g,idx)$name
neighborIdxs <- sapply(neighborIds,function(i){
which(i == V(g)$name)
})
#g
neighborIdxs <- sapply(neighborsIds,function(i){
which(i == V(g)$name)
})
neighborIdxs
neighborsIds
neighborLabels
# pre dane indexy ziskame v sieti labely
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
maxTblFrequency
labels
which(table(neighborIdxs) == maxTblFrequency))
which(table(neighborIdxs) == maxTblFrequency)
maxTblFrequency
ames(which(table(neighborIdxs) == maxTblFrequency)
names(which(table(neighborIdxs) == maxTblFrequency))
names(which(table(neighborIdxs) == maxTblFrequency)
names(which(table(neighborIdxs) == maxTblFrequency))
as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
g
ids <- V(g)$name
id <- ids[1]
idx <- which(id == V(g)$name)
neighborsIds <- neighbors(g,idx)$name
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
!(V(g)$label[idx]  %in% optimalLabels)
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
idx <- which(id == V(g)$name)
neighborsIds <- neighbors(g,idx)$name
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
jeSietOptimalna(g)
lpa(g)
o <- lpa(g)
isClusteringOptimal(o)
jeSietOptimalna(karate)
data(karate)
library(igraph)
data(karate)
library(igraphdata)
data(karate)
jeSietOptimalna(karate)
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
print(id)
idx <- which(id == V(g)$name)
neighborsIds <- neighbors(g,idx)$name
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
jeSietOptimalna(karate)
jeSietOptimalna(g)
ids <- V(g)$name
ids
id <- ids[1]
id
print(id)
idx <- which(id == V(g)$name)
idx
neighborsIds <- neighbors(g,idx)$name
neighborsIds
labels <- V(g)$label[neighborIdxs]
labels
maxTblFrequency
maxTblFrequency
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
optimalLabels
V(g)$label[idx]  %in% optimalLabels
!(V(g)$label[idx]  %in% optimalLabels)
V(g)$label[idx]
#17.
robAlgoritmus <- function(g){
resampledNameVector <- sample(V(g)$name)
numOfNodes <- length(resampledNameVector)
for(i in 1:numOfNode){
currentNodeId <- resampledNameVector[i]
currentNodeIdx <- which(currentNodeId == V(g)$name)
neighborIds <- neighbors(g,currentNodeIdx)$name
neighborIdxs <- sapply(neighborIds,function(i){
which(i == V(g)$name)
})
neighborLabels <- V(g)$label[neighborIdxs]
maxFreqLabel <- neighborLabels[1]
if(length(table(neighborLabels))!=1){
maxFreqLabel <- names(which.max(sample((table(neighborLabels)))))
}
V(g)$label[currentNodeIdx] <- maxFreqLabel
}
return(g)
}
robAlgoritmus(g)
#17.
robAlgoritmus <- function(g){
resampledNameVector <- sample(V(g)$name)
numOfNodes <- length(resampledNameVector)
for(i in 1:numOfNodes){
currentNodeId <- resampledNameVector[i]
currentNodeIdx <- which(currentNodeId == V(g)$name)
neighborIds <- neighbors(g,currentNodeIdx)$name
neighborIdxs <- sapply(neighborIds,function(i){
which(i == V(g)$name)
})
neighborLabels <- V(g)$label[neighborIdxs]
maxFreqLabel <- neighborLabels[1]
if(length(table(neighborLabels))!=1){
maxFreqLabel <- names(which.max(sample((table(neighborLabels)))))
}
V(g)$label[currentNodeIdx] <- maxFreqLabel
}
return(g)
}
robAlgoritmus(g)
V(robAlgoritmus(g))$label
lpa <- function(g){
if(class(g)!='igraph'){
return('Input must be type of igraph!')
}
networkLength <- length(V(g))
V(g)$label <- 1:networkLength
V(g)$name <- 1:networkLength
while(!jeSietOptimalna(g)){
g <- robAlgoritmus(g)
}
# p) ak chceme vratit vystup ako ostatne algoritmy pouzijeme funkciu make_clusters(g,membership=naseLabele)
clusteredReturn <- make_clusters(g,membership = shiftMembership(V(g)$label), algorithm= 'Vlastny label propagination algoritmus')
return(clusteredReturn)
}
lpa(g)
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
print(ids)
idx <- which(id == V(g)$name)
neighborsIds <- neighbors(g,idx)$name
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
idx <- which(id == V(g)$name)
neighborsIds <- neighbors(g,idx)$name
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
robAlgoritmus <- function(g){
resampledNameVector <- sample(V(g)$name)
numOfNodes <- length(resampledNameVector)
for(i in 1:numOfNodes){
currentNodeId <- resampledNameVector[i]
currentNodeIdx <- which(currentNodeId == V(g)$name)
neighborIds <- neighbors(g,currentNodeIdx)$name
neighborIdxs <- sapply(neighborIds,function(i){
which(i == V(g)$name)
})
neighborLabels <- V(g)$label[neighborIdxs]
maxFreqLabel <- neighborLabels[1]
if(length(table(neighborLabels))!=1){
maxFreqLabel <- names(which.max(sample((table(neighborLabels)))))
}
V(g)$label[currentNodeIdx] <- maxFreqLabel
}
return(g)
}
lpa <- function(g){
if(class(g)!='igraph'){
return('Input must be type of igraph!')
}
networkLength <- length(V(g))
V(g)$label <- 1:networkLength
V(g)$name <- 1:networkLength
while(!jeSietOptimalna(g)){
g <- robAlgoritmus(g)
}
clusteredReturn <- make_clusters(g,membership = shiftMembership(V(g)$label), algorithm= 'Vlastny label propagination algoritmus')
return(clusteredReturn)
}
robAlgoritmus(g)
isClusteringOptimal(robAlgoritmus(g))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
isClusteringOptimal(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
eSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
idx <- which(id == ids)
neighborsIds <- neighbors(g,idx)$name
neighborIdxs <- sapply(neighborsIds,function(i){
which(i == V(g)$name)
})
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
jeSietOptimalna(robAlgoritmus(robAlgoritmus(g)))
opt <- robAlgoritmus(robAlgoritmus(g))
isClusteringOptimal(opt)
g
keep <- g
g <- opt
ids <- V(g)$name
ids
id <- 15
idx <- which(id == ids)
idx
neighborsIds <- neighbors(g,idx)$name
neighborsIds
neighborIdxs <- sapply(neighborsIds,function(i){
which(i == V(g)$name)
})
neighborIdxs
labels <- V(g)$label[neighborIdxs]
labels
maxTblFrequency <- max(table(labels))
maxTblFrequency
optimalLabels <- as.vector(names(which(table(neighborIdxs) == maxTblFrequency)))
optimalLabels
which(table(neighborIdxs) == maxTblFrequency))
which(table(neighborIdxs) == maxTblFrequency)
neighborIdxs
optimalLabels <- as.vector(names(which(table(labels) == maxTblFrequency)))
optimalLabels
!(V(g)$label[idx]  %in% optimalLabels)
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
idx <- which(id == ids)
neighborsIds <- neighbors(g,idx)$name
neighborIdxs <- sapply(neighborsIds,function(i){
which(i == V(g)$name)
})
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(labels) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
isClusteringOptimal(keep)
V(keep)$label
g
V(g)$label
isClusteringOptimal(g)
jeSietOptimalna(g)
jeSietOptimalna<- function(g){
ids <- V(g)$name
for(id in ids){
idx <- which(id == ids)
neighborsIds <- neighbors(g,idx)$name
neighborIdxs <- sapply(neighborsIds,function(i){
which(i == V(g)$name)
})
labels <- V(g)$label[neighborIdxs]
maxTblFrequency <- max(table(labels))
optimalLabels <- as.vector(names(which(table(labels) == maxTblFrequency)))
if(!(V(g)$label[idx]  %in% optimalLabels)   ) {
return(FALSE)
}
}
return(TRUE)
}
robAlgoritmus <- function(g){
resampledNameVector <- sample(V(g)$name)
numOfNodes <- length(resampledNameVector)
for(i in 1:numOfNodes){
currentNodeId <- resampledNameVector[i]
currentNodeIdx <- which(currentNodeId == V(g)$name)
neighborIds <- neighbors(g,currentNodeIdx)$name
neighborIdxs <- sapply(neighborIds,function(i){
which(i == V(g)$name)
})
neighborLabels <- V(g)$label[neighborIdxs]
maxFreqLabel <- neighborLabels[1]
if(length(table(neighborLabels))!=1){
maxFreqLabel <- names(which.max(sample((table(neighborLabels)))))
}
V(g)$label[currentNodeIdx] <- maxFreqLabel
}
return(g)
}
lpa <- function(g){
if(class(g)!='igraph'){
return('Input must be type of igraph!')
}
networkLength <- length(V(g))
V(g)$label <- 1:networkLength
V(g)$name <- 1:networkLength
while(!jeSietOptimalna(g)){
g <- robAlgoritmus(g)
}
clusteredReturn <- make_clusters(g,membership = shiftMembership(V(g)$label), algorithm= 'Vlastny label propagination algoritmus')
return(clusteredReturn)
}
lpa(g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(g),g)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
plot(lpa(karate),karate)
library(igraph) source('data.R') source('utils.R') # samotna funkcia na prevolavanie algoritmu # arg:g typu igraph # arg:plot typu boolean - ci ma vyplotovat vysledok alebo nie, defaultne FALSE # arg:byFixedLabels - ci ma algoritmus clustrovat podla typu labelov a nie podla susednosti, napr. volicov nejakej strany do jedneho konkrenteho zhluku, defaultne FALSE lpa <- function(g,plot=FALSE, byFixedLabels = FALSE){ if(class(g)!='igraph'){ return('Input must be type of igraph!') } # nastavi labele a names podla toho aky vstupny graf sme dostali g <- initGraphSetter(g) j <- 0 # cyklus sa opakuje az pokial nebude vyhodnoteny ako optimalny while(!isClusteringOptimal(g, checkLabels = byFixedLabels )){ print(j) # uprava siete podla logiky algoritmu g <- algorithmLogic(g,byFixedLabels = byFixedLabels) j<- j +1 } print(paste("Total num. of iteration:", j)) clusteredReturn <- make_clusters(g,membership = shiftMembership(V(g)$label), algorithm= 'Vlastny label propagination algoritmus') if(plot){ plot(clusteredReturn,g, layout = layout_nicely(g), vertex.label = V(g)$label, vertex.label.cex = 0.75) } return(clusteredReturn) }
library(igraph) #vytvorenie nejakych umelych dat... getPreferencieNetwork <- function(labels= TRUE,num){ g <- make_full_graph(2) g <- add_vertices(g,13) if(labels==TRUE) { labelNames <- c('SAS','SAS','?','?','?','PS','SMER','?','?','?','?','PS','?','?','?') } if(labels==FALSE){ labelNames <- rep('?',15) } g <- add.edges(g,c(1,3,1,4,2,3,2,4,3,4,4,5,5,6,5,7,6,7,6,8,6,9,6,10,7,8,7,9,7,10,8,9,8,10,9,10,8,13,13,14,14,11,14,12,14,15,15,11,15,12)) labelCol <- labelNames labelCol[labelCol=='SAS'] <- 'green' labelCol[labelCol=='PS'] <- '2' labelCol[labelCol=='SMER'] <- 'red' labelCol[labelCol=='?'] <- 0 V(g)$label.cex <- 0.72 V(g)$label <- labelNames if(!is.null(num)){ set.seed(num) } plot(g, layout=layout_nicely(g), vertex.label=labelNames, vertex.size=18, vertex.color = labelCol, vertex.label.family="Times") return(g) } # pref <- getPreferencieNetwork(FALSE,3) # set.seed(3) # plot(pref, vertex.label = floor(runif(15)*16), vertex.color = 0, # layout=layout_nicely(pref), # vertex.size=18, # vertex.label.family="Times") #logika algoritmu algorithmLogic <- function(g,byFixedLabels = FALSE){ #poprehadzovanie ideciek siete resampledNameVector <- sample(V(g)$name) # ak su nejake fixnute nody, ktorych nody nechceme menit zadane explicitne + existuju, tak ich vyradime z nasemplovaneho vektoru if(byFixedLabels==TRUE && length(g$nameOfFixedLabels)>0){ resampledNameVector <- resampledNameVector[!(resampledNameVector %in% g$nameOfFixedLabels)] } numOfNodes <- length(resampledNameVector) # kazdy node si prezrie a zmeni mu label podla logiky algoritmu for(i in 1:numOfNodes){ currentNodeId <- resampledNameVector[i] #index id v povodnej sieti currentNodeIdx <- which(currentNodeId == V(g)$name) #ked sa vyhladava podla int, tak hlada podla poradia V(g)$name, ked podla stringu tak hlada konkretne id neighborIds <- neighbors(g,currentNodeIdx)$name neighborIdxs <- sapply(neighborIds,function(i){ which(i == V(g)$name) }) neighborLabels <- V(g)$label[neighborIdxs] # kontig. tabulka -> presampluju sa vysledne stlpce -> vybere sa prvy s maximalnymm stlpcom -> tj. ze ak su dva # uplne rovnake tak vrati spravodlivo nahodne jeden z nich maxFreqLabel <- neighborLabels[1] # ak je dlzka==1 tak bol problem so samplovanim tabulky sample(c(1,1,1)) -> 1, 2, 3, tak sa to takto osetrilo... if(length(table(neighborLabels))!=1){ maxFreqLabel <- names(which.max(sample((table(neighborLabels))))) } V(g)$label[currentNodeIdx] <- maxFreqLabel } return(g) } # lubovolny vektor napr. c(1,100,100,2,6,49) presunie na -> c(1,5,5,2,3,4), teda usporiadava jeho elemtny od najnizsieho po najvacsi # vyuzitelnost pri tom aby membership napr nebol 1, 100, 2, 6 ,49 ale 1:5, tym padom dostavame aj relevantnu informaciu o tok, kolko membershipov sa celkovo nachadza pre dany graf shiftMembership <- function(vector){ uniqueVector <- sort(unique(vector)) newVector <- match(vector, uniqueVector) for (i in unique(vector)) { idx <- which(vector == i) if (length(idx) > 1) { newVector[idx[2:length(idx)]] <- newVector[idx[2:length(idx)]] } } return(newVector) } isClusteringOptimal <- function(g,checkLabels = FALSE){ ids <- V(g)$name for(id in ids){ if(checkLabels==TRUE && length(g$nameOfFixedLabels) >0 && id %in% g$nameOfFixedLabels) next currentNodeIdx <- which(id == ids) neighborIds <- neighbors(g,currentNodeIdx)$name neighborIdxs <- sapply(neighborIds,function(i){ which(i == V(g)$name) }) neighborLabels <- V(g)$label[neighborIdxs] maxTblFrequency <- max(table(neighborLabels)) optimalLabels <- as.vector(names(which(table(neighborLabels) == maxTblFrequency))) if(!(V(g)$label[currentNodeIdx] %in% optimalLabels) ) { return(FALSE) } } return(TRUE) } customSample <- function(vec){ if(max(vec)==min(vec)){ return(vec) } return(sample(vec)) } # handluje labele a name pre dany graf, ak nie su nastavy ich ak su iba nejake tak zvysne vygeneruje ak nie su ziadne tak nastavi uplne vsetky initGraphSetter <- function(g){ # najprv sa pozrie na id/names grafu a setne ten names <- V(g)$name if(is.null(names)){ V(g)$name <- 1:length(g) } # ak su ale nejake id prazdne a ine nie tak prazdnym prideli hodnotu V(g)$name <- as.vector(sapply(V(g)$name, function(i){ if(i == '' | i == '?' | i == ' '){ return(uuid::UUIDgenerate()) } return(i) })) # pozrieme sa na labels if(is.null(V(g)$label)){ V(g)$label <- 1:length(g) } # ak nie je null, tak si uschovame idecka takych nodov, ktorych labele na zaciatku boli setnute g$nameOfFixedLabels <- V(g)$name[(V(g)$label!= '?' & V(g)$label != '' & V(g)$label != ' ')] # prazdne labele inicializujeme nahodnymi unikatnymi retazcami V(g)$label <- as.vector(sapply(V(g)$label, function(i){ if(i == '' | i == '?' | i == ' '){ return(uuid::UUIDgenerate()) } return(i) })) return(g) } # samotna funkcia na prevolavanie algoritmu # arg:g typu igraph # arg:plot typu boolean - ci ma vyplotovat vysledok alebo nie, defaultne FALSE # arg:byFixedLabels - ci ma algoritmus clustrovat podla typu labelov a nie podla susednosti, napr. volicov nejakej strany do jedneho konkrenteho zhluku, defaultne FALSE lpa <- function(g,plot=FALSE, byFixedLabels = FALSE){ if(class(g)!='igraph'){ return('Input must be type of igraph!') } # nastavi labele a names podla toho aky vstupny graf sme dostali g <- initGraphSetter(g) j <- 0 # cyklus sa opakuje az pokial nebude vyhodnoteny ako optimalny while(!isClusteringOptimal(g, checkLabels = byFixedLabels )){ print(j) # uprava siete podla logiky algoritmu g <- algorithmLogic(g,byFixedLabels = byFixedLabels) j<- j +1 } print(paste("Total num. of iteration:", j)) clusteredReturn <- make_clusters(g,membership = shiftMembership(V(g)$label), algorithm= 'Vlastny label propagination algoritmus') if(plot){ plot(clusteredReturn,g, layout = layout_nicely(g), vertex.label = V(g)$label, vertex.label.cex = 0.75) } return(clusteredReturn) }
source.url('http://127.0.0.1:5500/code.html', method="auto")
source('http://127.0.0.1:5500/code.html', method="auto")
source('http://127.0.0.1:5500/code.html')
install.packages("devtools")
library(devtools)
source_url('ll')
sourcetools::read()
sourcetools::read('aaa')
source_url("https://gist.github.com/hadley/6872663/raw/hi.r")
if(!require('devtools')) {
install.packages('devtools')
library('devtools')
}
install.packages("devtools")
library(devtools)
library('devtools')
library(devtools)
library(devtools)
install.packages("devtools")
